scchart pacemaker {
  input bool as, vs;
  output bool ap, vp;
  input int t_lri, t_uri, t_avi, t_pvarp, t_vrp, t_aei;
  output bool LRI, URI, AVI, PVARP, VRP, AEI;
  output bool LRI_p, URI_p, AVI_p, PVARP_p, VRP_p, AEI_p;


  region pulse_a:

  initial state off {
    entry / ap = false
  }
  --> on_sense with (as & !PVARP)
  --> on_pulse with AEI_p;

  state on_sense {
    entry / ap = true
  }
  --> off with true;
  
  state on_pulse {
    entry / ap = true
  }
  --> off with true;


  region pulse_v:

  initial state off {
    entry / vp = false
  }
  --> on_sense with vs & !VRP
  --> on_pulse with URI_p;

  state on_sense {
    entry / vp = true
  }
  --> off with true;
  
  state on_pulse {
    entry / vp = true
  }
  --> off with true;


  region avi:
  int time;

  initial state off {
    entry / AVI = false;
    entry / AVI_p = false;
    entry / time = 0
  }
  --> on with ap;

  state on {
    entry / AVI = true
  }
  --> off with vp
  --> on with time < t_avi / time ++
  --> p_off with time == t_avi;

  state p_off {
    entry / AVI = false;
    entry / AVI_p = true
  }
  --> off with true;


  region pvarp:
  int time;

  initial state off {
    entry / PVARP = false;
    entry / PVARP_p = false;
    entry / time = 0
  }
  --> on with vp;

  state on {
    entry / PVARP = true
  }
  --> on with time < t_pvarp / time ++
  --> p_off with time == t_pvarp;

  state p_off {
    entry / PVARP = false;
    entry / PVARP_p = true
  }
  --> off with true;


  region vrp:
  int time;

  initial state off {
    entry / VRP = false;
    entry / VRP_p = false;
    entry / time = 0;
  }
  --> on with vp;

  state on {
    entry / VRP = true
  }
  --> on with time < t_vrp / time ++
  --> p_off with time == t_vrp;

  state p_off {
    entry / VRP_p = true
  }
  --> off with true;
  
/*
  region aei:
  int time;

  initial state off {
    entry / AEI = false;
    entry / AEI_p = false;
    entry / time = 0;
  }
  --> on with vp;

  state on {
    entry / AEI = true
  }
  --> off with ap
  --> on with time < t_aei / time ++
  --> p_off with time == t_aei;

  state p_off {
    entry / AEI_p = true
  }
  --> off with true;


  region lri:
  int time;

  initial state off {
    entry / LRI = false;
    entry / LRI_p = false;
    entry / time = 0;
  }
  --> on with vp;

  state on {
    entry / LRI = true
  }
  --> on with time < t_lri / time ++
  --> p_off with time == t_lri;

  state p_off {
    entry / LRI_p = true
  }
  --> off with true;


  region uri:
  int time;

  initial state off {
    entry / URI = false;
    entry / URI_p = false;
    entry / time = 0;
  }
  --> on with vp;

  state on {
    entry / URI = true
  }
  --> on with time < t_uri / time ++
  --> p_off with time == t_uri;

  state p_off {
    entry / URI_p = true
  }
  --> off with true; */
}